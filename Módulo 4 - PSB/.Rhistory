labs(title = "EMG3", x = "Amplitude", y = "Densidade") +
theme_minimal()
# Combinando os gráficos em um painel
(box_emg1 | hist_emg1 | densid_emg1) /
(box_emg2 | hist_emg2 | densid_emg2) /
(box_emg3 | hist_emg3 | densid_emg3)
library(kableExtra)
library(e1071)
library(dplyr)
# Calculando a média com a função mean()
media_EMG1 <- mean(dados_EMG1$Amplitudes)
media_EMG2 <- mean(dados_EMG2$Amplitudes)
media_EMG3 <- mean(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
media_EMG1_3 <- round(media_EMG1, 3)
media_EMG2_3 <- round(media_EMG2, 3)
media_EMG3_3 <- round(media_EMG3, 3)
# Calculando o desvio padrão
dp_EMG1 <- sd(dados_EMG1$Amplitudes)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dp_EMG3 <- sd(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
dp_EMG1_3 <- round(dados_EMG1, 3)
dp_EMG2_3 <- round(dados_EMG2, 3)
dp_EMG3_3 <- round(dados_EMG3, 3)
# Calculando a variância
v_EMG1 <- var(dados_EMG1$Amplitudes)
library(kableExtra)
library(e1071)
library(dplyr)
# Calculando a média com a função mean()
media_EMG1 <- mean(dados_EMG1$Amplitudes)
media_EMG2 <- mean(dados_EMG2$Amplitudes)
media_EMG3 <- mean(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
media_EMG1_3 <- round(media_EMG1, 3)
media_EMG2_3 <- round(media_EMG2, 3)
media_EMG3_3 <- round(media_EMG3, 3)
# Calculando o desvio padrão
dp_EMG1 <- sd(dados_EMG1$Amplitudes)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dp_EMG3 <- sd(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
dp_EMG1_3 <- round(dados_EMG1, 3)
dp_EMG2_3 <- round(dados_EMG2, 3)
dp_EMG3_3 <- round(dados_EMG3, 3)
# Calculando a variância
v_EMG1 <- var(dados_EMG1$Amplitude)
v_EMG2 <- var(dados_EMG2$Amplitude)
v_EMG3 <- var(dados_EMG3$Amplitude)
# Arredondando o resultado para 3 casas decimais
v_EMG1_3 <- round(v_EMG1, 3)
v_EMG2_3 <- round(v_EMG2, 3)
v_EMG3_3 <- round(v_EMG3, 3)
# Calculando o coeficiente de assimetria
coefassim_EMG1 <- skewness(df_EMG1$Amplitudes)
library(kableExtra)
library(e1071)
library(dplyr)
# Calculando a média com a função mean()
media_EMG1 <- mean(dados_EMG1$Amplitudes)
media_EMG2 <- mean(dados_EMG2$Amplitudes)
media_EMG3 <- mean(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
media_EMG1_3 <- round(media_EMG1, 3)
media_EMG2_3 <- round(media_EMG2, 3)
media_EMG3_3 <- round(media_EMG3, 3)
# Calculando o desvio padrão
dp_EMG1 <- sd(dados_EMG1$Amplitudes)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dp_EMG3 <- sd(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
dp_EMG1_3 <- round(dados_EMG1, 3)
dp_EMG2_3 <- round(dados_EMG2, 3)
dp_EMG3_3 <- round(dados_EMG3, 3)
# Calculando a variância
v_EMG1 <- var(dados_EMG1$Amplitude)
v_EMG2 <- var(dados_EMG2$Amplitude)
v_EMG3 <- var(dados_EMG3$Amplitude)
# Arredondando o resultado para 3 casas decimais
v_EMG1_3 <- round(v_EMG1, 3)
v_EMG2_3 <- round(v_EMG2, 3)
v_EMG3_3 <- round(v_EMG3, 3)
# Calculando o coeficiente de assimetria
coefassim_EMG1 <- skewness(dados_EMG1$Amplitude)
coefassim_EMG2 <- skewness(dados_EMG2$Amplitude)
coefassim_EMG3 <- skewness(dados_EMG3$Amplitude)
# Arredondando resultado para 3 casas decimais
coefassim_EMG1_3 <- round(coefassim_EMG1, 3)
coefassim_EMG2_3 <- round(coefassim_EMG2, 3)
coefassim_EMG3_3 <- round(coefassim_EMG3, 3)
# Calculando a curtose
curt_EMG1 <- kurtosis(df_EMG1$Amplitudes)
library(kableExtra)
library(e1071)
library(dplyr)
# Calculando a média com a função mean()
media_EMG1 <- mean(dados_EMG1$Amplitudes)
media_EMG2 <- mean(dados_EMG2$Amplitudes)
media_EMG3 <- mean(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
media_EMG1_3 <- round(media_EMG1, 3)
media_EMG2_3 <- round(media_EMG2, 3)
media_EMG3_3 <- round(media_EMG3, 3)
# Calculando o desvio padrão
dp_EMG1 <- sd(dados_EMG1$Amplitudes)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dp_EMG3 <- sd(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
dp_EMG1_3 <- round(dados_EMG1, 3)
dp_EMG2_3 <- round(dados_EMG2, 3)
dp_EMG3_3 <- round(dados_EMG3, 3)
# Calculando a variância
v_EMG1 <- var(dados_EMG1$Amplitude)
v_EMG2 <- var(dados_EMG2$Amplitude)
v_EMG3 <- var(dados_EMG3$Amplitude)
# Arredondando o resultado para 3 casas decimais
v_EMG1_3 <- round(v_EMG1, 3)
v_EMG2_3 <- round(v_EMG2, 3)
v_EMG3_3 <- round(v_EMG3, 3)
# Calculando o coeficiente de assimetria
coefassim_EMG1 <- skewness(dados_EMG1$Amplitude)
coefassim_EMG2 <- skewness(dados_EMG2$Amplitude)
coefassim_EMG3 <- skewness(dados_EMG3$Amplitude)
# Arredondando resultado para 3 casas decimais
coefassim_EMG1_3 <- round(coefassim_EMG1, 3)
coefassim_EMG2_3 <- round(coefassim_EMG2, 3)
coefassim_EMG3_3 <- round(coefassim_EMG3, 3)
# Calculando a curtose
curt_EMG1 <- kurtosis(dados_EMG1$Amplitude)
curt_EMG2 <- kurtosis(dados_EMG2$Amplitude)
curt_EMG3 <- kurtosis(dados_EMG3$Amplitude)
# Arredondando resultado para 3 casas decimais
curt_EMG1_3 <- round(curt_EMG1, 3)
curt_EMG2_3 <- round(curt_EMG2, 3)
curt_EMG3_3 <- round(curt_EMG3, 3)
# Criando um dataframe com os resultados
df <- data.frame(sinais = c("EMG1", "EMG2", "EMG3"),
mean = c(media_EMG1_3, media_EMG2_3, media_EMG3_3),
dp = c(dp_EMG1_3, dp_EMG2_3, dp_EMG3_3),
var = c(v_EMG1_3, v_EMG2_3, v_EMG3_3),
ca = c(coefassim_EMG1_3, coefassim_EMG2_3, coefassim_EMG3_3),
curtose = c(curt_EMG1_3, curt_EMG2_3, curt_EMG3_3))
nrow(dados_EMG1)
nrow(dados_EMG2)
nrow(dados_EMG3)
names(dados_EMG1)  # Verifique o nome das colunas do dataframe
names(dados_EMG2)
names(dados_EMG3)
library(kableExtra)
library(e1071)
library(dplyr)
# Calculando a média com a função mean()
media_EMG1 <- mean(dados_EMG1$Amplitudes)
media_EMG2 <- mean(dados_EMG2$Amplitudes)
media_EMG3 <- mean(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
media_EMG1_3 <- round(media_EMG1, 3)
media_EMG2_3 <- round(media_EMG2, 3)
media_EMG3_3 <- round(media_EMG3, 3)
# Calculando o desvio padrão
dp_EMG1 <- sd(dados_EMG1$Amplitudes)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dp_EMG3 <- sd(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
dp_EMG1_3 <- round(dp_EMG1, 3)
dp_EMG2_3 <- round(dp_EMG2, 3)
dp_EMG3_3 <- round(dp_EMG3, 3)
# Calculando a variância
v_EMG1 <- var(dados_EMG1$Amplitudes)
library(kableExtra)
library(e1071)
library(dplyr)
# Calculando a média com a função mean()
media_EMG1 <- mean(dados_EMG1$Amplitudes)
media_EMG2 <- mean(dados_EMG2$Amplitudes)
media_EMG3 <- mean(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
media_EMG1_3 <- round(media_EMG1, 3)
media_EMG2_3 <- round(media_EMG2, 3)
media_EMG3_3 <- round(media_EMG3, 3)
# Calculando o desvio padrão
dp_EMG1 <- sd(dados_EMG1$Amplitudes)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dp_EMG3 <- sd(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
dp_EMG1_3 <- round(dp_EMG1, 3)
dp_EMG2_3 <- round(dp_EMG2, 3)
dp_EMG3_3 <- round(dp_EMG3, 3)
# Calculando a variância
v_EMG1 <- var(dados_EMG1$Amplitude)
v_EMG2 <- var(dados_EMG2$Amplitude)
v_EMG3 <- var(dados_EMG3$Amplitude)
# Arredondando o resultado para 3 casas decimais
v_EMG1_3 <- round(v_EMG1, 3)
v_EMG2_3 <- round(v_EMG2, 3)
v_EMG3_3 <- round(v_EMG3, 3)
# Calculando o coeficiente de assimetria
coefassim_EMG1 <- skewness(dados_EMG1$Amplitude)
coefassim_EMG2 <- skewness(dados_EMG2$Amplitude)
coefassim_EMG3 <- skewness(dados_EMG3$Amplitude)
# Arredondando resultado para 3 casas decimais
coefassim_EMG1_3 <- round(coefassim_EMG1, 3)
coefassim_EMG2_3 <- round(coefassim_EMG2, 3)
coefassim_EMG3_3 <- round(coefassim_EMG3, 3)
# Calculando a curtose
curt_EMG1 <- kurtosis(dados_EMG1$Amplitude)
curt_EMG2 <- kurtosis(dados_EMG2$Amplitude)
curt_EMG3 <- kurtosis(dados_EMG3$Amplitude)
# Arredondando resultado para 3 casas decimais
curt_EMG1_3 <- round(curt_EMG1, 3)
curt_EMG2_3 <- round(curt_EMG2, 3)
curt_EMG3_3 <- round(curt_EMG3, 3)
# Criando um dataframe com os resultados
df <- data.frame(sinais = c("EMG1", "EMG2", "EMG3"),
mean = c(media_EMG1_3, media_EMG2_3, media_EMG3_3),
dp = c(dp_EMG1_3, dp_EMG2_3, dp_EMG3_3),
var = c(v_EMG1_3, v_EMG2_3, v_EMG3_3),
ca = c(coefassim_EMG1_3, coefassim_EMG2_3, coefassim_EMG3_3),
curtose = c(curt_EMG1_3, curt_EMG2_3, curt_EMG3_3))
# Exibindo o dataframe formatado com kableExtra
df %>% kbl() %>% kable_styling()
sum(is.na(dados_EMG1$Amplitudes))
sum(is.na(dados_EMG2$Amplitudes))
sum(is.na(dados_EMG3$Amplitudes))
sum(is.infinite(dados_EMG1$Amplitudes))  # Verifique se há infinitos
sum(is.infinite(dados_EMG2$Amplitudes))
sum(is.infinite(dados_EMG3$Amplitudes))
sum(dados_EMG1$Amplitudes == 0)  # Verifique se há zeros
sum(dados_EMG2$Amplitudes == 0)
sum(dados_EMG3$Amplitudes == 0)
str(dados_EMG1$Amplitudes)
str(dados_EMG2$Amplitudes)
str(dados_EMG3$Amplitudes)
dados_EMG1$Amplitudes <- as.numeric(dados_EMG1$Amplitudes)
library(pracma)
library(ggplot2)
library(dplyr)
fs1 <- 1000
dt1 <- 1/fs1
tempo <- seq(0, 30, by = dt1)
media1 <- 0.8
desvio_padrao1 <- 1.3
# Gerando ruído com distribuição normal
ruido1 <- randn(length(tempo), 1)
EMG1 <- media1 + desvio_padrao1 * ruido1
dados_EMG1 <- data.frame(Tempo = tempo, Amplitude = EMG1)
grafico_EMG1 <- ggplot(dados_EMG1, aes(x = Tempo, y = Amplitude)) +
geom_line(color = "grey") +
labs(x = "Tempo (s)", y = "Amplitude do EMG1") +
theme_minimal()
# Exibe o gráfico do EMG1
grafico_EMG1
library(pracma)
library(tidyverse)
fs2 <- 300
dt2 <- 1/fs2
tempo2 <- seq(0, 30, by = dt2)
media2 <- 1.8
desvio_padrao2 <- 0.9
# Gerando ruído para o EMG2
ruido2 <- randn(length(tempo2), 1)
EMG2 <- media2 + desvio_padrao2 * ruido2
dados_EMG2 <- data.frame(Tempo = tempo2, Amplitude = EMG2)
grafico_EMG2 <- ggplot(dados_EMG2, aes(x = Tempo, y = Amplitude)) +
geom_line(color = "black") +
labs(x = "Tempo (s)", y = "Amplitude do EMG2") +
theme_minimal()
# Exibe o gráfico do EMG2
grafico_EMG2
# Realizando interpolação para EMG2
df_c <- data.frame(spline(x = tempo2, y = EMG2, xout = tempo))
amplitude_interpolado <- df_c$y
# Calculando o EMG3
EMG3 <- EMG1 + amplitude_interpolado
dados_EMG3 <- data.frame(Tempo = tempo, Amplitude = EMG3)
grafico_EMG3 <- ggplot(dados_EMG3, aes(x = Tempo, y = Amplitude)) +
geom_line(color = "brown") +
labs(x = "Tempo (s)", y = "Amplitude do EMG3") +
theme_minimal()
# Exibe o gráfico do EMG3
grafico_EMG3
library(ggplot2)
library(patchwork)
# Boxplot do sinal EMG1
box_emg1 <- ggplot(dados_EMG1, aes(x = Amplitude)) +
geom_boxplot() +
labs(x = "EMG1", y = "Amplitude") +
theme_minimal()
# Histograma do sinal EMG1
hist_emg1 <- ggplot(dados_EMG1, aes(x = Amplitude)) +
geom_histogram(binwidth = 0.5, fill = "blue", color = "black") +
labs(title = "EMG1", x = "Amplitude", y = "Frequência") +
theme_minimal()
# Densidade do sinal EMG1
densid_emg1 <- ggplot(dados_EMG1, aes(x = Amplitude)) +
geom_density(fill = "blue", color = "black") +
labs(title = "EMG1", x = "Amplitude", y = "Densidade") +
theme_minimal()
# Boxplot do sinal EMG2
box_emg2 <- ggplot(dados_EMG2, aes(x = Amplitude)) +
geom_boxplot() +
labs(x = "EMG2", y = "Amplitude") +
theme_minimal()
# Histograma do sinal EMG2
hist_emg2 <- ggplot(dados_EMG2, aes(x = Amplitude)) +
geom_histogram(binwidth = 0.5, fill = "purple", color = "black") +
labs(title = "EMG2", x = "Amplitude", y = "Frequência") +
theme_minimal()
# Densidade do sinal EMG2
densid_emg2 <- ggplot(dados_EMG2, aes(x = Amplitude)) +
geom_density(fill = "purple", color = "black") +
labs(title = "EMG2", x = "Amplitude", y = "Densidade") +
theme_minimal()
# Boxplot do sinal EMG3
box_emg3 <- ggplot(dados_EMG3, aes(x = Amplitude)) +
geom_boxplot() +
labs(x = "EMG3", y = "Amplitude") +
theme_minimal()
# Histograma do sinal EMG3
hist_emg3 <- ggplot(dados_EMG3, aes(x = Amplitude)) +
geom_histogram(binwidth = 0.5, fill = "pink", color = "black") +
labs(title = "EMG3", x = "Amplitude", y = "Frequência") +
theme_minimal()
# Densidade do sinal EMG3
densid_emg3 <- ggplot(dados_EMG3, aes(x = Amplitude)) +
geom_density(fill = "pink", color = "black") +
labs(title = "EMG3", x = "Amplitude", y = "Densidade") +
theme_minimal()
# Combinando os gráficos em um painel
(box_emg1 | hist_emg1 | densid_emg1) /
(box_emg2 | hist_emg2 | densid_emg2) /
(box_emg3 | hist_emg3 | densid_emg3)
library(kableExtra)
library(e1071)
library(dplyr)
# Calculando a média com a função mean()
media_EMG1 <- mean(dados_EMG1$Amplitudes)
media_EMG2 <- mean(dados_EMG2$Amplitudes)
media_EMG3 <- mean(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
media_EMG1_3 <- round(media_EMG1, 3)
media_EMG2_3 <- round(media_EMG2, 3)
media_EMG3_3 <- round(media_EMG3, 3)
# Calculando o desvio padrão
dp_EMG1 <- sd(dados_EMG1$Amplitudes)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dp_EMG3 <- sd(dados_EMG3$Amplitudes)
# Arredondando o resultado para 3 casas decimais
dp_EMG1_3 <- round(dp_EMG1, 3)
dp_EMG2_3 <- round(dp_EMG2, 3)
dp_EMG3_3 <- round(dp_EMG3, 3)
# Calculando a variância
v_EMG1 <- var(dados_EMG1$Amplitude)
v_EMG2 <- var(dados_EMG2$Amplitude)
v_EMG3 <- var(dados_EMG3$Amplitude)
# Arredondando o resultado para 3 casas decimais
v_EMG1_3 <- round(v_EMG1, 3)
v_EMG2_3 <- round(v_EMG2, 3)
v_EMG3_3 <- round(v_EMG3, 3)
# Calculando o coeficiente de assimetria
coefassim_EMG1 <- skewness(dados_EMG1$Amplitude)
coefassim_EMG2 <- skewness(dados_EMG2$Amplitude)
coefassim_EMG3 <- skewness(dados_EMG3$Amplitude)
# Arredondando resultado para 3 casas decimais
coefassim_EMG1_3 <- round(coefassim_EMG1, 3)
coefassim_EMG2_3 <- round(coefassim_EMG2, 3)
coefassim_EMG3_3 <- round(coefassim_EMG3, 3)
# Calculando a curtose
curt_EMG1 <- kurtosis(dados_EMG1$Amplitude)
curt_EMG2 <- kurtosis(dados_EMG2$Amplitude)
curt_EMG3 <- kurtosis(dados_EMG3$Amplitude)
# Arredondando resultado para 3 casas decimais
curt_EMG1_3 <- round(curt_EMG1, 3)
curt_EMG2_3 <- round(curt_EMG2, 3)
curt_EMG3_3 <- round(curt_EMG3, 3)
# Criando um dataframe com os resultados
df <- data.frame(sinais = c("EMG1", "EMG2", "EMG3"),
mean = c(media_EMG1_3, media_EMG2_3, media_EMG3_3),
dp = c(dp_EMG1_3, dp_EMG2_3, dp_EMG3_3),
var = c(v_EMG1_3, v_EMG2_3, v_EMG3_3),
ca = c(coefassim_EMG1_3, coefassim_EMG2_3, coefassim_EMG3_3),
curtose = c(curt_EMG1_3, curt_EMG2_3, curt_EMG3_3))
# Exibindo o dataframe formatado com kableExtra
df %>% kbl() %>% kable_styling()
library(tidyverse)
# Amplitudes do Sinal (1) - Alta precisão e alta exatidão
temp1 <- rnorm(1000, mean = 25, sd = 0.5)
temp1 <- pmax(pmin(temp1, 30), 20)
# Amplitudes do Sinal (2) - Baixa precisão e alta exatidão
temp2 <- runif(1000, min = 22, max = 28)
temp2 <- pmax(pmin(temp2, 30), 20)
# Amplitudes do Sinal (3) - Alta precisão e baixa exatidão
temp3 <- rnorm(1000, mean = 23, sd = 0.5)
temp3 <- pmax(pmin(temp3, 30), 20)
# Amplitudes do Sinal (4) - Baixa precisão e baixa exatidão
temp4 <- runif(1000, min = 20, max = 30)
temp4 <- pmax(pmin(temp4, 30), 20)
# Criando vetor de tempo
t <- rep(1:1000, 4)
# Criando data frames para os sinais
df1 <- data.frame(temperatura = temp1, t = t, group = 'Alta precisão e alta exatidão')
df2 <- data.frame(temperatura = temp2, t = t, group = 'Baixa precisão e alta exatidão')
df3 <- data.frame(temperatura = temp3, t = t, group = 'Alta precisão e baixa exatidão')
df4 <- data.frame(temperatura = temp4, t = t, group = 'Baixa precisão e baixa exatidão')
# Unindo os data frames
df <- rbind(df1, df2, df3, df4)
# Plotando os sinais ao longo do tempo
ggplot(df, aes(x = t, y = temperatura, color = group)) +
geom_line() +
scale_color_manual(values = c("red", "blue", "green", "purple")) +
facet_wrap(~ group, ncol = 1, scales = "free_y") +
xlab("Tempo") +
ylab("Temperatura (°C)") +
theme_minimal()
# Plotando as distribuições das temperaturas
ggplot(df, aes(x = temperatura, fill = group)) +
geom_density(alpha = 0.5) +
scale_fill_manual(values = c("pink", "orange", "gray", "yellow")) +
xlab("Temperatura (°C)") +
ylab("Densidade") +
theme_classic()
library(dygraphs)
library(tidyverse)
dadosm4 <- read.table("E:/GitHub/PSB/Módulo 4 - PSB/DadosM4-1.txt", header = FALSE, sep =  " ", skip = 6)
# Alterando o nome das variávesi do df
names(dadosm4) <- c("AccX", "AccY", "MuscAnterior", "MuscPosterior")
# Criando vetor tempo
fs <- 500
# Definindo intervalo entre amostrar
dt <- 1/fs
# Definindo vetor tempo (s)
t <- seq(from=0, to = dt*(length(dadosm4$AccY)-1), by = dt)
dadosm4 <- cbind(time = t, dadosm4)
# Plotagem do gráfico
dygraph(dadosm4[c("time", "AccY")], main = "AccY", group = "GroupName") %>%
dyRangeSelector()
# Amplitude Máxima
AmpMAX_AccY <- max(dadosm4$AccY) - min(dadosm4$AccY)
lim_min <- 0.9 * AmpMAX_AccY
# Encontrando os picos e armazenando os valores
dadosm4 <- dadosm4 %>%
mutate(pico = ifelse(dadosm4$AccY - min(dadosm4$AccY) >= lim_min, dadosm4$AccY, NA))
# Plotagem do gráfico
ggplot(dadosm4, aes(x = time, y = pico)) +
geom_line(na.rm = TRUE) +
labs(title = "Amplitudes de AccY >= 90% da Max. Amplitude",
x = "Tempo",
y = "AccY")
# Cálculo dos parâmetros
x <- dadosm4$MuscPosterior  # Definição da variável correta
# Tamanho da janela
janela <- 500
# Índice dos picos encontrados
indice_picos <- which(!is.na(dadosm4$pico))
# Criando um data frame vazio para armazenar os resultados
df <- data.frame()
# Loop para percorrer os picos
for (i in indice_picos){
indx1 <- i - floor(janela / 2)
indx2 <- i + ceiling(janela / 2) - 1
# Cálculo dos valores desejados
if(indx1 > 0 & indx2 <= length(x)) {
media <- mean(x[indx1:indx2])
mediana <- median(x[indx1:indx2])
moda <- as.numeric(names(table(x[indx1:indx2]))[which.max(table(x[indx1:indx2]))])
amplitude <- max(x[indx1:indx2]) - min(x[indx1:indx2])
variancia <- var(x[indx1:indx2])
cv <- sd(x[indx1:indx2]) / mean(x[indx1:indx2])
iqr <- IQR(x[indx1:indx2])
# Armazenando os resultados no data frame
df <- rbind(df, data.frame(pico = i, media = media, mediana = mediana, moda = moda,
amplitude = amplitude, variancia = variancia, cv = cv, iqr = iqr))
}
}
# Exibindo o data frame com os resultados
df
# Seleção do sinal de interesse
y <- dadosm4$MuscPosterior
# Definição do tamanho da janela (número de amostras)
Nwnd <- 500
# Gerando os índices iniciais de cada janela
indx1 <- seq(from = 1, to = length(y), by = Nwnd)
N <- length(indx1)  # Número de janelas
# Inicializando um data frame para armazenar os resultados
dfenv <- data.frame(
time = rep(NA, times = N - 1),
mediana = NA
)
# Loop para calcular a mediana em cada janela
for (i in 1:(N - 1)) {
# Calcula o tempo centralizado em cada janela
dfenv$time[i] <- (indx1[i] + (indx1[i + 1] - indx1[i]) / 2) * dt
# Calcula a mediana do sinal na janela atual
dfenv$mediana[i] <- median(y[indx1[i]:indx1[i + 1]])
}
# Plotando os resultados
dygraph(dfenv, main = "Mediana x Tempo", group = "GroupName") %>%
dyRangeSelector()
dados_EMG1$Amplitudes
dados_EMG1
View(dados_EMG1)
dados_EMG1$Amplitude
View(dados_EMG2)
sd(dados_EMG1$Amplitude)
dp_EMG1
dp_EMG1 <- sd(dados_EMG1$Amplitude)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
dados_EMG2$Amplitude
sd(dados_EMG2$Amplitude)
dp_EMG2 <- sd(dados_EMG2$Amplitudes)
