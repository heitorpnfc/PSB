---
title: " "
author: " "
date: " "
output: 
  html_document:
    df_print: paged
  pdf_document:
    highlight: tango
always_allow_html: true
---

\newpage
\begin{titlepage}
\begin{center}

\large
UNIVERSIDADE FEDERAL DE UBERLÂNDIA\\
FACULDADE DE ENGENHARIA ELÉTRICA\\
GRADUAÇÃO EM ENGENHARIA BIOMÉDICA\\[7cm]

\Large
\textbf{Heitor Pereira Nunes Fernandes Cunha}\\[2cm]

\textbf{\large Processamento de Sinais Biomédicos: Módulo 8}\\[10cm]

\large
Uberlândia, MG\\
2025

\end{center}
\end{titlepage}

\newpage
\section*{Questão 1}

> Questão 1

Dado a frequência f = 0.3rad/s, calcule os valores de frequência em ciclos/s, rad/amostra e ciclos/amostra. Assuma o valor de fs = 200 Hz.

```{r}

# Definindo os valores
omega <- 0.3     # Frequência em rad/s
fs <- 200        # Frequência de amostragem em Hz (amostras/s)

# 1) Frequência em ciclos/s (Hz)
freq_ciclos_s <- omega / (2 * pi)

# 2) Frequência em rad/amostra
freq_rad_amostra <- omega / fs

# 3) Frequência em ciclos/amostra
freq_ciclos_amostra <- freq_ciclos_s / fs
# ou, equivalentemente:
# freq_ciclos_amostra <- freq_rad_amostra / (2*pi)

# Exibindo os resultados
cat("Frequência em ciclos/s (Hz) =", freq_ciclos_s, "ciclos/s\n")
cat("Frequência em rad/amostra =", freq_rad_amostra, "rad/amostra\n")
cat("Frequência em ciclos/amostr =", freq_ciclos_amostra, "ciclos/amostra\n")

```
\newpage
\section*{Questão 2}

> Questão 2

Gere 5 segundos de um sinal s, que deve ser a soma de dois sinais senoidais, sendo um oscilando a 60 ciclos/s e o outro a 100 ciclos por segundo. Adote a frequência de amostragem de 1,2 kHZ. Aplique a equação recursiva ao sinal se responda às questões abaixo:

y[n] = 1,8523y[n-1] - 0.94833y[n-2] + x[n] - 1.9021x[n-1] + x[n-2]

```{r}

library(dygraphs)
library(tidyverse)

# Parâmetros de geração do sinal
fs <- 1200           # Frequência de amostragem (Hz)
T <- 5               # Duração (s)
N <- T * fs          # Número total de amostras

# Vetor de tempo
t <- seq(0, by = 1/fs, length.out = N)

# 2) Gerando o sinal x[n] = sen(2π60t) + sen(2π100t)

f1 <- 60             # 60 Hz
f2 <- 100            # 100 Hz

# Sinais senoidais
x1 <- sin(2*pi*f1*t)
x2 <- sin(2*pi*f2*t)

# Sinal total de entrada
x <- x1 + x2

# Aplicando a equação recursiva:

# Para armazenar a saída y:
y <- numeric(N)

for (n in 3:N) {
  y[n] <- 1.8523 * y[n-1] - 0.94833 * y[n-2] +
          x[n]     - 1.9021 * x[n-1]   + x[n-2]
}

# Visualização ou análise de resultados

# Plot do sinal de entrada
plot(t[1:(fs)], x[1:(fs)], type = "l", 
     main = "Sinal de entrada x[n]",
     xlab = "Tempo (s)", ylab = "Amplitude")

# Plot do sinal de saída
plot(t[1:(fs)], y[1:(fs)], type = "l", 
     main = "Saída após a equação recursiva",
     xlab = "Tempo (s)", ylab = "Amplitude")


```

> Letra A

Qual foi o principal efeito de se aplicar a equação de y[n] sobre o sinal s?

O principal efeito de aplicar a equação recursiva: y[n] = 1,8523y[n-1] - 0.94833y[n-2] + x[n] - 1.9021x[n-1] + x[n-2], sobre o sinal s (soma das senoides de 60 Hz e 100 Hz) é filtrar essas componentes de frequência de maneira que uma ou ambas sejam atenuadas ou reforçadas, dependendo de como os polos e zeros do filtro (definido pelos coeficientes) afetam cada faixa de frequência; em outras palavras, o filtro modifica a amplitude e a fase das senoides originais, resultando em um sinal de saída que não é mais a simples soma das duas ondas, mas sim uma versão alterada por esse sistema IIR de segunda ordem.

> Letra B

Esboce o diagrama de blocos que ilustre o processador descrito por y[n].

\begin{center}
\includegraphics[width=0.8\textwidth]{E:/GitHub/PSB/Módulo 8 - PSB/Diagrama}\\[2cm]
\end{center}

\newpage
\section*{Questão 3}

> Questão 3

Calcule a resposta ao impulso unitário, h[n], para o processador:

y[n] = y[n−1] + (1/L)x[n] − x[n−L].

```{r}



```

\newpage
\section*{Questão 4}

> Questão 4

Gere 5 segundos de um sinal senoidal amostra a 500 Hz, oscilando a 30 Hz, e adicione ruído gaussiano (com amplitude de no máximo 10% ao valor máximo do sinal senoida). Aplique o processador da questão 3 ao sinal resultante. Qual foi o efeito observado? Plote os gráficos do sinal origina, corrompido e processado.

```{r}

library(tuneR)

# Parâmetros gerais
fs <- 500         # Frequência de amostragem (Hz)
duracao <- 5      # Duração (s)
N <- fs * duracao # Número total de amostras
t <- seq(0, by=1/fs, length.out=N)

f_seno <- 30      # Frequência da senoide (Hz)
amp_seno <- 1     # Amplitude da senoide

# Gera sinal senoidal
x_original <- amp_seno * sin(2*pi*f_seno*t)

# Gera ruído branco usando a função noise()
ruido_obj <- noise(kind = "white", duration = duracao, samp.rate = fs, xunit = "time")
ruido <- ruido_obj@left 
ruido <- ruido[1:N]

# Escala o ruído para que seu valor máximo seja 10% do pico da senoide
# O pico da senoide (amplitude 1) é 1, então 10% = 0.1
ruido <- ruido / max(abs(ruido)) * 0.1

# Sinal corrompido
x_corrompido <- x_original + ruido

# Processador:
L <- 5
y_processado <- numeric(N)

for(n in 1:N) {
  if(n == 1) {
    y_prev <- 0
  } else {
    y_prev <- y_processado[n-1]
  }
  
  if((n-L) < 1) {
    x_nmL <- 0
  } else {
    x_nmL <- x_corrompido[n-L]
  }
  
  y_processado[n] <- y_prev + (1/L)*x_corrompido[n] - x_nmL
}

# 5) Plot dos sinais
plot(t, x_original, type="l", 
     main="(A) Sinal Original (30 Hz, 5s, fs=500 Hz)",
     xlab="Tempo (s)", ylab="Amplitude")

plot(t, x_corrompido, type="l",
     main="(B) Sinal Corrompido (ruído branco até 10% de amplitude)",
     xlab="Tempo (s)", ylab="Amplitude")

plot(t, y_processado, type="l",
     main=paste("(C) Sinal Processado pelo Filtro (L =", L, ")"),
     xlab="Tempo (s)", ylab="Amplitude")

```
\newpage
\section*{Questão 5}

> Questão 5

Calcule a resposta em frequência, H(z) de y[n]=0.5[x(n)+x[n−1]]. Faça o gráfico da amplitude e fase. Que tipo de processador é esse?

```{r}

# Carregar bibliotecas necessárias
library(signal)
library(REdaS)
library(ggplot2)

numerador <- c(0.5, 0.5)
denominador <- c(1)
taxa_amostragem <- 500

# Calcular a resposta em frequência do filtro
resposta_freq <- freqz(numerador, denominador, Fs = taxa_amostragem)

# Obter módulo da resposta em frequência
modulo <- Mod(resposta_freq$h)

# Calcular fase em radianos e converter para graus
fase_rad <- Arg(resposta_freq$h)
fase_graus <- rad2deg(fase_rad)

# Converter módulo para escala decibéis
modulo_db <- 20 * log10(modulo)

# Criar dataframe com os resultados para visualização
dados_plot <- data.frame(
  frequencia = resposta_freq$f,
  resposta_complexa = resposta_freq$h,
  fase_rad,
  fase_graus,
  modulo,
  modulo_db
)

# Gráfico do módulo
ggplot(dados_plot, aes(x = frequencia, y = modulo)) +
  geom_line() +
  theme_classic() +
  labs(title = "Módulo da Resposta em Frequência", x = "Frequência (Hz)", y = "|H(f)|")

# Gráfico da fase em graus
ggplot(dados_plot, aes(x = frequencia, y = fase_graus)) +
  geom_line() +
  theme_classic() +
  labs(title = "Fase da Resposta em Frequência", x = "Frequência (Hz)", y = "Fase (graus)")

# Gráfico do módulo em decibéis
ggplot(dados_plot, aes(x = frequencia, y = modulo_db)) +
  geom_line() +
  theme_classic() +
  labs(title = "Resposta em Frequência (dB)", x = "Frequência (Hz)", y = "Magnitude (dB)")

```
Trata-se de um filtro FIR de 2 coeficientes que efetua a média simples de duas amostras consecutivas (1/2*[x(n)+x(n−1)]). Em termos de resposta em frequência, ele se comporta como um filtro passa-baixas, atenuando as componentes em altas frequências (onde atinge ganho zero em w = pi) e mantém o ganho máximo de w = 0.

\newpage
\section*{Questão 6}

> Questão 6

Simule três bursts de sinais eletromiográficos em um tempo de 10 s. Cada burst deve ter a duração de 2 segundos. Assuma que o sinal foi amostrado a 1000 Hz. Promova um ganho de 1.2 vezes nos trecho em que há atividade eletromiográfica. Filtre o sinal gerado com um fitro passa-baixa, com frequência de corte de 5 Hz e ordem 3. Faça a comparação entre sinais filtrados pelos filtros Butterworth e Chebyshev. Plote os gráficos dos sinais obtidados e as respostas em frequência dos filtros utilizados. Dicas: (i) para a geração do sinal utilize a função randn. (ii) Para a filtragem do sinal utilize a função filtfilt.

```{r}

# Carregamento das bibliotecas
library(pracma)
library(signal)
library(ggplot2)
library(dplyr)

# Configurações iniciais
frequencia_amostragem <- 1000
intervalo_tempo <- 1 / frequencia_amostragem
tempo <- seq(from = 0, to = 10, by = intervalo_tempo)

# Geração de ruído branco (base do sinal)
sinal_base <- as.vector(randn(n = length(tempo), m = 1))
dados <- data.frame(tempo)

# Definição do burst do EMG
tempo_burst <- seq(from = 0, to = 2, by = intervalo_tempo)
constante <- 0.001
gerar_burst <- function(t) {
  t * (2 - constante * t) * exp(-constante * t)
}
sinal_burst <- gerar_burst(1:10000)

# Interpolação para ajustar ao tempo
sinal_burst <- spline(x = 1:10000, y = sinal_burst, xout = 1:10000)$y

# Inserção dos bursts em 2s, 5s e 8s
pontos_insercao <- c((2/intervalo_tempo + 1), (5/intervalo_tempo + 1), (8/intervalo_tempo + 1))
dados$burst <- rep(NA, length(tempo))

for (i in 1:3) {
  inicio <- pontos_insercao[i]
  fim <- min(inicio + length(sinal_burst) - 1, length(tempo))  # evitar ultrapassar limites
  comprimento <- fim - inicio + 1
  dados$burst[inicio:fim] <- sinal_burst[1:comprimento]
}

# Visualização dos bursts
ggplot(dados) +
  geom_line(aes(x = tempo, y = burst)) +
  theme_bw(base_size = 20) +
  labs(x = "Tempo (s)", y = "Amplitude dos Bursts")

# Soma do ruído com os bursts
dados <- dados %>%
  mutate(
    burst = ifelse(is.na(burst), 0, burst),
    sinal_total = sinal_base + burst
  )

# Amplificação dos trechos com burst
for (i in 1:3) {
  inicio <- pontos_insercao[i]
  fim <- min(inicio + length(sinal_burst) - 1, nrow(dados))  # evita ultrapassar o limite do data.frame
  dados$sinal_total[inicio:fim] <- 1.2 * dados$sinal_total[inicio:fim]
}

# Visualização do sinal completo com bursts amplificados
ggplot(dados) +
  geom_line(aes(x = tempo, y = sinal_total)) +
  theme_bw(base_size = 20) +
  labs(x = "Tempo(s)", y = "Amplitude com Amplificação")

# Criação do filtro Butterworth (ordem 3, 5 Hz)
ordem <- 3
frequencia_corte <- 5
frequencia_normalizada <- frequencia_corte / (frequencia_amostragem / 2)
filtro_butter <- butter(ordem, frequencia_normalizada, type = "low")
freqz(filt = filtro_butter, Fs = frequencia_amostragem)

# Criação do filtro Chebyshev Tipo I (ordem 3, 5 Hz, ripple 0.5 dB)
ripple <- 0.5
filtro_cheby <- cheby1(ordem, ripple, frequencia_normalizada, type = "low")
freqz(filt = filtro_cheby, Fs = frequencia_amostragem)

# Aplicação dos filtros
dados$sinal_butter <- filtfilt(filt = filtro_butter, dados$sinal_total)
dados$sinal_cheby <- filtfilt(filt = filtro_cheby, dados$sinal_total)

# Gráfico comparativo dos sinais
cores <- c("Original" = "black", "Butterworth" = "darkorange", "Chebyshev" = "darkgreen")
ggplot(data.frame()) +
  geom_line(data = dados, aes(x = tempo, y = sinal_total, color = "Original")) +
  geom_line(data = dados, aes(x = tempo, y = sinal_butter, color = "Butterworth")) +
  geom_line(data = dados, aes(x = tempo, y = sinal_cheby, color = "Chebyshev")) +
  theme_bw(base_size = 20) +
  labs(x = "Tempo(s)", y = "Amplitude do Sinal", color = "Tipo de Sinal") +
  scale_color_manual(values = cores)

# Zoom no primeiro burst (0 a 3 segundos)
ggplot(data.frame()) +
  geom_line(data = dados, aes(x = tempo, y = sinal_total, color = "Original")) +
  geom_line(data = dados, aes(x = tempo, y = sinal_butter, color = "Butterworth")) +
  geom_line(data = dados, aes(x = tempo, y = sinal_cheby, color = "Chebyshev")) +
  theme_bw(base_size = 20) +
  coord_cartesian(xlim = c(0, 3)) +
  labs(x = "Tempo(s)", y = "Amplitude do Sinal", color = "Tipo de Sinal") +
  scale_color_manual(values = cores)

```
